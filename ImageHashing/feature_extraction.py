import numpy as np
import cv2
from skimage.feature import greycomatrix, greycoprops
from typing import Tuple


def get_GLCM(intensity: np.ndarray) -> np.ndarray:
    """
    Generate GLCM from intensity component of the input image.
    :param intensity: intensity component of the input image (all float values).
    :return: GLCM
    """
    # in the paper: d = 1
    dist = [1]
    # in the paper: theta = 0째, 45째, 90째, 135째
    theta = [0, np.pi / 4, np.pi / 2, 3 * np.pi / 4]

    # calculate GLCM
    glcm = greycomatrix(intensity, distances=dist, angles=theta, levels=256)
    return glcm


def get_global_texture_feature(glcm: np.ndarray) -> np.ndarray:
    """
    Generate global texture features T.
    :param glcm: GLCM generated from intensity component of origin image.
    :return: global texture features T.
    """
    texture_feature = None
    for prop in {'contrast', 'correlation', 'energy', 'homogeneity'}:
        tmp = greycoprops(glcm, prop)
        # normalization
        # tmp = (tmp - np.min(tmp)) / (np.max(tmp) - np.min(tmp))
        # standardization
        tmp = (tmp - np.mean(tmp)) / np.std(tmp)
        # print(f'{prop}: {tmp}')
        if texture_feature is None:
            texture_feature = tmp
        else:
            texture_feature = np.hstack((texture_feature, tmp))

    feature = texture_feature[0]
    # feature = (feature - np.mean(feature)) / np.std(feature)
    # feature = (feature - np.min(feature)) / (np.max(feature) - np.min(feature))
    return feature


def get_local_distance_feature(intensity: np.ndarray, b: int) -> np.ndarray:
    """
    Get local distance feature from intensity component.
    :param intensity: intensity component of the input image (all float values).
    :param b: the intensity component is divided into non-overlapping sub-images sized b * b.
    :return: vector distance.
    """
    intensity = intensity.astype(np.float)
    B = intensity.shape[0]
    n = B // b   # N = n ** 2

    # generate feature matrix according to matrix generated by DCT
    feature_matrix = None
    for i in range(n):
        for j in range(n):
            sub_img = intensity[i * b: (i + 1) * b, j * b: (j + 1) * b]
            sub_dct = cv2.dct(sub_img)
            first_row = sub_dct[0, 1: b // 2 + 1].reshape((b // 2, 1))
            first_col = sub_dct[1: b // 2 + 1, 0].reshape((b // 2, 1))
            vector_q = np.vstack((first_row, first_col))
            if feature_matrix is None:
                feature_matrix = vector_q
            else:
                feature_matrix = np.hstack((feature_matrix, vector_q))

    # apply data normalization to every row of feature_matrix
    mean = np.mean(feature_matrix, axis=1).reshape((b, 1))
    std = np.std(feature_matrix, axis=1).reshape((b, 1))
    feature_matrix = (feature_matrix - mean) / std

    # calculate vector distance between DCT low-frequency coefficients
    U0 = np.mean(feature_matrix, axis=1).reshape((b, 1))
    vector_distance = np.sqrt(np.sum((feature_matrix - U0) ** 2, axis=0))

    return vector_distance


def extract_features(intensity: np.ndarray, b: int) -> np.ndarray:
    """
    Extract features from intensity component of the input image.
    :param intensity: intensity component of the input image.
    :param b: width and length of sub-image used to generate local distance feature.
    :return: feature of the image: F = [TD]
    """
    glcm = get_GLCM(intensity)
    T = get_global_texture_feature(glcm)
    D = get_local_distance_feature(intensity, b)
    return np.hstack((T, D))


def cal_coefficients(img: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
    """
    Function to test whether cv2.dct() function used the same principle as in the paper.
    :param img: input matrix where DCT should be applied
    :return: the first row and column of the matrix after DCT
    """
    b = img.shape[0]
    row = []
    col = []
    for v in range(b):
        row_ele = 0
        col_ele = 0
        for j in range(b):
            for k in range(b):
                row_ele += img[j][k] * np.cos((2 * k + 1) * v * np.pi / (2 * b))
                col_ele += img[j][k] * np.cos((2 * j + 1) * v * np.pi / (2 * b))
        row_ele *= np.sqrt(2) / b
        col_ele *= np.sqrt(2) / b
        row.append(row_ele)
        col.append(col_ele)

    return np.array(row), np.array(col)
